Challenge;Predicate;Expression;HiGenATED;HiGenAPopularNode;HiGenAPopularEdge;specTed;specPopularNode;specPopularEdge
dkZH6HJNQNLLDX6Aj;inv5;all inf : Influencer | all u: User | inf in u.follows;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the one of expression.;Keep going! Consider adding a disjunction operator ('or') to combine two boolean expressions. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.
dkZH6HJNQNLLDX6Aj;inv5;all u:User, i:Influencer | i in u.follows;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Instead of using signature of type User, try using signature of type Influencer to help satisfy the required property.;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Instead of using signature of type User, try using signature of type Influencer to help satisfy the required property.;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.
dkZH6HJNQNLLDX6Aj;inv5;all x : Influencer | all p : User | p in follows.x;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.;Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.;Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the one of expression.;Keep going! Consider adding a disjunction operator ('or') to combine two boolean expressions. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.
dkZH6HJNQNLLDX6Aj;inv1;all x : Photo | some y : User | y->x in posts;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using dot join operator ('.') to perform a relational join between sets or relations.
dkZH6HJNQNLLDX6Aj;inv1;all p : Photo | p in User.posts;Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.;Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.
dkZH6HJNQNLLDX6Aj;inv1;all p:Photo | some u:User | p in u.posts;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.
dkZH6HJNQNLLDX6Aj;inv7;all u : User | u.suggested in u.follows.follows and u.suggested not in u.follows;Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.;One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using disjunction operator ('or') to combine two boolean expressions.;Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.
dkZH6HJNQNLLDX6Aj;inv7;all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested;Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the disjoint operator ('disj'). If you want to keep it, try to fix your expression another way and reach a different solution!;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! It seems like the conjunction operator ('and') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.
dkZH6HJNQNLLDX6Aj;inv7;all u1,u2 : User | u2 in u1.suggested implies u2 in u1.follows.follows and u2 not in u1.follows;Keep going! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.;Keep going! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.;Near a solution! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.
dkZH6HJNQNLLDX6Aj;inv4;all x:User| some a:Ad| a in x.posts implies x.posts in Ad;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.
dkZH6HJNQNLLDX6Aj;inv4;all u : User | one a : Ad | a in u.posts => u.posts in Ad;One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.;Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.;Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.
dkZH6HJNQNLLDX6Aj;inv4;all u : User | some p : Photo | (p in u.posts and p in Ad) implies (all p2: Photo | p2 in u.posts implies p2 in Ad);Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.;Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.;Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.;One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.;Keep going! Consider adding a one of to help satisfy the required property. Think about how you can incorporate this within the universal quantifier ('all') expression.;One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.
